# Data
Summary of data types, data containers, and how they are used by autogeneration. Language specific notes are also detailed.

## Data Types
The following data types are supported across RSIS, though some are restricted in their usage in specific scenarios. The names of the data types as found in rust are used. Generally speaking, variable-sized data types are not allowed for usage with port inputs and outputs.

Rust and Julia data types have first class support. C++ and Fortran are provided for integration with legacy code. `--` indicates that a type is unsupported for the target language, and generally RSIS will throw errors upon encountering that data type during autogeneration for that target language.

| Rust | C++ | Fortran | Julia |
| --- | --- | --- | --- |
| i8 | int8_t | integer(c_int8_t) | Int8 |
| i16 | int16_t | integer(c_int16_t) | Int16 |
| i32 | int32_t | integer(c_int32_t) | Int32 |
| i64 | int64_t | integer(c_int64_t) | Int64 |
| u8 | uint8_t | -- | UInt8 |
| u16 | uint16_t | -- | UInt16 |
| u32 | uint32_t | -- | UInt32 |
| u64 | uint64_t | -- | UInt64 |
| f32 | float | real(c_float) | Float32 |
| f64 | double | real(c_double) | Float64 |
| bool | bool | logical(c_bool) | Bool |
| char | char | character(c_char) | Char |
| String | std::string | character(:), allocatable | String |
| usize | std::size_t | integer(c_size_t) | Cssize_t |
| isize | std::ptrdiff_t | integer(c_ptrdiff_t) | Cptrdiff_t |

C++ and Fortran wrappers have an option between using FFI or using MessagePack to handle internal data flow. Usage of dynamically allocated types will disable FFI, e.g. `String`. See [MessagePack](./MessagePack.md) for more information about how it is used within RSIS.

### Matrices
The `SMatrix` generic is used to support statically sized matrix types in rust code. The `nalgebra` crate is used to support this.

### Containers
The following containers are supported. Containers are not available for block ports. Containers are specified in the interface file via setting the `type` key to a list, e.g:

```toml
vals = {type=["Vec", "i32"], desc="internal temperature"}
map = {type=["HashMap", "String", "String"], desc=""}
```

Dimensions and units cannot be specified for containers.

| Rust | C++ | Fortran | Julia |
| --- | --- | --- | --- |
| Vec&lt;T&gt; | std::vector&lt;T&gt; | -- | Vector{T} |
| HashMap&lt;K, V&gt; | std::unordered_map&lt;K, V&gt; | -- | Dict{K, V}
| BTreeMap&lt;K, V&gt; | std::map&lt;K, V&gt; | -- | Dict{K, V} |
| HashSet&lt;T&gt; | std::unordered_set&lt;T&gt; | -- | Set{T} |

Notes:
- A Julia `Vector` is not equivalent to Rust's `Vec` data type, but it is enough for integration with the Julia wrapper
- `std::map` is not equivalent to `BTreeMap` from an implementation POV. It is roughly equivalent from the perspective of ordering. In Julia, it is expected that the user will iterate over the `Dict` with sorted Keys rather than use a specific data type

### Special Types
| Rust | C++ | Fortran | Julia |
| --- | --- | --- | --- |
| Complex&lt;f32&gt; | std::complex&lt;float&gt; | complex(kind=real32) | Complex{Float32} |
| Complex&lt;f64&gt; | std::complex&lt;double&gt; | complex(kind=real64) | Complex{Float64} |
| Ratio&lt;i32&gt; | -- | -- | Rational{Int32} |
| Ratio&lt;i64&gt; | -- | -- | Rational{Int64} |

Notes:
- RSIS relies on the `num_complex` crate for complex numbers.
- RSIS relies on the `num_rational` crate for rational numbers.

## Paths
Paths to block inputs, outputs, data, and parameters are done via the usage of the `.` character.

Paths to specific elements of a matric or a container-type items are not supported.

## Unsupported Rust Types
It is often desirable for a block to store a type that is not directly supported with RSIS. With some restrictions, RSIS lets you specify custom data types for the data and parameter elements. 

```toml
myrng = {custom="rand::rngs::ThreadRng", crate="rand", desc="a random number generator"}
```

Restrictions:
- A MessagePack serialization/deserialization function will not be generated by default for custom data types. If the user provides the required functions, then the `expose=true` flag can be passed in the interface file to let the autogeneration system know that the custom field is supported.
- If MessagePack integration is not provided, the save feature of RSIS will not save a value for that element into the generated binary file.
